<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>算法笔记： 跳表 | Bad Fd</title>

    



<meta name="author" content="" />
<meta name="description" content="这是读书时一篇旧文搬运.几年后再次回顾下算法.
 跳表是一种著名数据结构。
 原理应该不用介绍了，rocksdb/redis内部都有使用skiplist。
相对于红黑树，它的优势我认为是实现简单，并且容易无锁化。
本文主要讨论：
 skiplist一些性质分析 skiplist核心思想&amp;amp;核心问题 rocksdb中的跳表实现分析  skiplist原理 property of a node   a node of skiplist   Q：给定某个skiplist的节点$x$,其含有以下4个level的next值：a(lvl=3),b(lvl=2),c(lvl=1),d(lvl=0),问：x,a,b,c,d之间满足什么关系？
A：$a &amp;gt; b &amp;gt; c &amp;gt; d &amp;gt; x$ (是否带等号看具体实现), 且lvl指向的子链表含有的元素的范围是 $$(next[lvl],next[lvl&#43;1])$$
key-idea  跳表 = 有序链表 &#43; 索引节点 查找：利用索引，理想状态下可以达到logn级别复杂度。  给定key的查找过：需要从最高level开始，逐步下降，直到lvl=0，每下降一个level就缩小了查找区间的范围。   插入/删除：如果该节点涉及多个level，需要变更所有level的前驱和后继。  实现细节：
  思路就是每一层都是一个有序链表，lvl&#43;1层是lvl层的索引。（索引本身也是数据）
  给定一个key值，可以找到一个前驱数组prev[...]（所有level比key小的最后一个节点）。
  任意前驱数组元素prev[i],满足性质： $$ 对于 i \in [0，currmax], 有： \
prev[i].key &amp;lt; key \qquad 且 \" />



<meta name="generator" content="Hugo 0.78.1" />

<link rel="canonical" href="/posts/algmnotes-skiplist/" />


<meta property="og:title" content="算法笔记： 跳表" />
<meta property="og:description" content="这是读书时一篇旧文搬运.几年后再次回顾下算法.
 跳表是一种著名数据结构。
 原理应该不用介绍了，rocksdb/redis内部都有使用skiplist。
相对于红黑树，它的优势我认为是实现简单，并且容易无锁化。
本文主要讨论：
 skiplist一些性质分析 skiplist核心思想&amp;核心问题 rocksdb中的跳表实现分析  skiplist原理 property of a node   a node of skiplist   Q：给定某个skiplist的节点$x$,其含有以下4个level的next值：a(lvl=3),b(lvl=2),c(lvl=1),d(lvl=0),问：x,a,b,c,d之间满足什么关系？
A：$a &gt; b &gt; c &gt; d &gt; x$ (是否带等号看具体实现), 且lvl指向的子链表含有的元素的范围是 $$(next[lvl],next[lvl&#43;1])$$
key-idea  跳表 = 有序链表 &#43; 索引节点 查找：利用索引，理想状态下可以达到logn级别复杂度。  给定key的查找过：需要从最高level开始，逐步下降，直到lvl=0，每下降一个level就缩小了查找区间的范围。   插入/删除：如果该节点涉及多个level，需要变更所有level的前驱和后继。  实现细节：
  思路就是每一层都是一个有序链表，lvl&#43;1层是lvl层的索引。（索引本身也是数据）
  给定一个key值，可以找到一个前驱数组prev[...]（所有level比key小的最后一个节点）。
  任意前驱数组元素prev[i],满足性质： $$ 对于 i \in [0，currmax], 有： \
prev[i].key &lt; key \qquad 且 \" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/algmnotes-skiplist/" />
<meta property="article:published_time" content="2020-03-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-03-01T00:00:00+00:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="算法笔记： 跳表"/>
<meta name="twitter:description" content="这是读书时一篇旧文搬运.几年后再次回顾下算法.
 跳表是一种著名数据结构。
 原理应该不用介绍了，rocksdb/redis内部都有使用skiplist。
相对于红黑树，它的优势我认为是实现简单，并且容易无锁化。
本文主要讨论：
 skiplist一些性质分析 skiplist核心思想&amp;核心问题 rocksdb中的跳表实现分析  skiplist原理 property of a node   a node of skiplist   Q：给定某个skiplist的节点$x$,其含有以下4个level的next值：a(lvl=3),b(lvl=2),c(lvl=1),d(lvl=0),问：x,a,b,c,d之间满足什么关系？
A：$a &gt; b &gt; c &gt; d &gt; x$ (是否带等号看具体实现), 且lvl指向的子链表含有的元素的范围是 $$(next[lvl],next[lvl&#43;1])$$
key-idea  跳表 = 有序链表 &#43; 索引节点 查找：利用索引，理想状态下可以达到logn级别复杂度。  给定key的查找过：需要从最高level开始，逐步下降，直到lvl=0，每下降一个level就缩小了查找区间的范围。   插入/删除：如果该节点涉及多个level，需要变更所有level的前驱和后继。  实现细节：
  思路就是每一层都是一个有序链表，lvl&#43;1层是lvl层的索引。（索引本身也是数据）
  给定一个key值，可以找到一个前驱数组prev[...]（所有level比key小的最后一个节点）。
  任意前驱数组元素prev[i],满足性质： $$ 对于 i \in [0，currmax], 有： \
prev[i].key &lt; key \qquad 且 \"/>


<link rel="stylesheet" href="/css/semantic.min.css" />
<link rel="stylesheet" href="/css/icomoon.css" />
<link rel="stylesheet" href="/css/OverlayScrollbars.min.css" />
<link rel="stylesheet" href="/css/github-markdown.css" />
<link rel="stylesheet" href="/css/site.css" />

<style>
  a:not(.ui.button):hover {
    text-decoration: underline;
  }

  

  

  

  
</style>


    







    
  </head>

  <body class="default">
    
<nav class="ui secondary menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title=""></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="" onclick="window.location.href = '\/'"></i>
  </div>
  
  
</nav>

    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          <div class="dream-max-width">
            
<div class="ui relaxed grid dream-grid">
  <aside class="sixteen wide mobile sixteen wide tablet four wide computer column dream-single-aside">
    
    
    <div class="ui segment toc">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#skiplist原理">skiplist原理</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#rocksdb的skiplist">rocksdb的skiplist</a>
      <ul>
        <li><a href="#rocksdb的memtable的几种实现">rocksdb的memtable的几种实现</a></li>
        <li><a href="#skiplist的实现">skiplist的实现</a></li>
        <li><a href="#几个疑问">几个疑问</a></li>
      </ul>
    </li>
    <li><a href="#reference">Reference</a></li>
  </ul>
</nav>
    </div>
    
    <div class="ui segment actions">
      <button
        class="ui circular icon button save-as-image"
        title=""
        onclick="savePostAsImg()">
        <i class="save icon"></i>
      </button>

      <a href="https://twitter.com/intent/tweet?text=%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0%ef%bc%9a%20%e8%b7%b3%e8%a1%a8&url=%2fposts%2falgmnotes-skiplist%2f" class="ui circular twitter icon button">
  <i class="twitter icon"></i>
</a>
<a href="https://facebook.com/sharer/sharer.php?u=%2fposts%2falgmnotes-skiplist%2f" class="ui circular facebook icon button">
  <i class="facebook icon"></i>
</a>

    </div>
  </aside>
  <div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single" id="dream-save-post-as-img">
    
    <section class="ui top attached segment">
      <header>
        <h1 class="ui large header">算法笔记： 跳表<div class="sub header">
            @
            
              
            

            | 
                Sunday, Mar 1, 2020
              

            | 1

            | 
              
                Sunday, Mar 1, 2020
              
          </div>
        </h1>
      </header>

      <article class="main"><p>这是读书时一篇旧文搬运.几年后再次回顾下算法.</p>
<blockquote>
<p>跳表是一种著名数据结构。</p>
</blockquote>
<p>原理应该不用介绍了，rocksdb/redis内部都有使用skiplist。</p>
<p>相对于红黑树，它的优势我认为是实现简单，并且容易无锁化。</p>
<p>本文主要讨论：</p>
<ul>
<li>skiplist一些性质分析</li>
<li>skiplist核心思想&amp;核心问题</li>
<li>rocksdb中的跳表实现分析</li>
</ul>
<h2 id="skiplist原理">skiplist原理</h2>
<h4 id="property-of-a-node">property of a node</h4>
<figure>
    <img src="../../resources/skiplist-node.png"/> <figcaption>
            <h4>a node of skiplist</h4>
        </figcaption>
</figure>

<p>Q：给定某个skiplist的节点$x$,其含有以下4个level的next值：a(lvl=3),b(lvl=2),c(lvl=1),d(lvl=0),问：x,a,b,c,d之间满足什么关系？</p>
<p>A：$a &gt; b &gt; c &gt; d &gt; x$ (是否带等号看具体实现), 且lvl指向的子链表含有的元素的范围是 $$(next[lvl],next[lvl+1])$$</p>
<h4 id="key-idea">key-idea</h4>
<ul>
<li>跳表 = 有序链表 + 索引节点</li>
<li>查找：利用索引，理想状态下可以达到<code>logn</code>级别复杂度。
<ul>
<li>给定key的查找过：需要从最高level开始，逐步下降，直到lvl=0，每下降一个level就缩小了查找区间的范围。</li>
</ul>
</li>
<li>插入/删除：如果该节点涉及多个level，需要变更<!-- raw HTML omitted -->所有level<!-- raw HTML omitted -->的前驱和后继。</li>
</ul>
<p>实现细节：</p>
<ul>
<li>
<p>思路就是每一层都是一个有序链表，lvl+1层是lvl层的索引。（索引本身也是数据）</p>
</li>
<li>
<p>给定一个key值，可以找到一个前驱数组<code>prev[...]</code>（所有level比key小的最后一个节点）。</p>
</li>
<li>
<p>任意前驱数组元素prev[i],满足性质：
$$
对于 i \in [0，currmax], 有：  \<br>
prev[i].key &lt; key  \qquad 且 \<br>
prev[i].next[i] &gt; key or prev[i].next[i] == null \<br>
$$
(PS：给定key和某skiplist，每一层应该只有1个这样的节点)</p>
</li>
</ul>
<h2 id="rocksdb的skiplist">rocksdb的skiplist</h2>
<h3 id="rocksdb的memtable的几种实现">rocksdb的memtable的几种实现</h3>
<p>(or 表示方式representation)</p>
<ul>
<li>skiplist</li>
<li>inlineskiplist *(by default)</li>
<li>hash-skiplist</li>
<li>hash-linklist</li>
<li>vector</li>
</ul>
<h3 id="skiplist的实现">skiplist的实现</h3>
<ul>
<li>
<p>两个参数默认值： int32_t max_height = 12, int32_t branching_factor = 4</p>
<ul>
<li>值得一提的是，其中<code>branching_factor</code>取4的话，正好对应论文里的P = 0.25，即生成的新节点为level+1的概率是level的1/4,。（PS：level=1的概率是1）</li>
</ul>
</li>
<li>
<p>skiplist节点内部核心数据：next指针数组</p>
<ul>
<li>数组长度是该节点的level，实现上采用了一个c里常见的<code>struct hack</code> + <code>placement new</code></li>
</ul>
</li>
<li>
<p>核心流程是查找，查找这里采用了双指针法，即给定key值，每次对比<code>curr</code>和<code>curr-&gt;next</code>看curr是否为key值在本lvl的前驱，若是，记录下，然后迭代到下一个lvl（lvl-1），缩小范围继续下一轮。</p>
</li>
<li>
<p>线程安全性</p>
<ul>
<li>skiplist节点内部指针均采用原子变量，原子变量的同步依赖于<code>acquire/release</code>语义（而没使用锁）</li>
</ul>
</li>
<li>
<p>fast-path-for-seq-insert</p>
<ul>
<li>利用上一次保存的prev数组，可以实现较快插入顺序元素（不需要再次构建一遍前驱数组）</li>
</ul>
</li>
<li>
<p>inlineskiplist：</p>
<ul>
<li>实际上rocksdb的memtable使用的是<code>inlineskiplist</code>(而没有用skiplist，which在leveldb里采用)</li>
</ul>
</li>
</ul>
<h3 id="几个疑问">几个疑问</h3>
<ul>
<li>对于std::atomic这种非POD类型，也能玩这种<code>struct hack</code>吗?</li>
<li>利用原子变量进行无锁化，需要十分注意memory-order, 那么acqure-release语义到底是什么东西？</li>
<li>其他机种memtable的实现优劣？</li>
</ul>
<p>这些超出本文讨论范围了，下次在讨论罢。</p>
<h2 id="reference">Reference</h2>
<ul>
<li>struct hack - flexible array. <a href="https://stackoverflow.com/questions/36577094/array-of-size-0-at-the-end-of-struct">https://stackoverflow.com/questions/36577094/array-of-size-0-at-the-end-of-struct</a></li>
</ul>
</article>
    </section>

    

    

    
  </div>
</div>


            <footer class="ui basic center aligned segment" style="background-color: transparent;">
              
              <p>© 2021 Bad Fd</p>
              

              <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>

              
            </footer>
          </div>
        </section>
        <section class="back">
          <div class="dream-max-width">
            <header class="ui basic very padded segment dream-header">
  <div class="ui small circular image">
    
  </div>

  <div class="content">
    <h1 class="ui medium header"><div class="sub header"></div>
    </h1>

    <article class="ui horizontal list">
      
      <a class="item" href="/posts">
        <i class="archive icon" title=""></i>
      </a>
      
      <a class="item" href="/categories">
        <i class="th list icon" title=""></i>
      </a>
      <a class="item" href="/tags">
        <i class="tags icon" title=""></i>
      </a>
    </article>

    
    <article class="dream-tags">
    
      
      
      <a class="ui label" href="/tags/container-iterator/" title="Container Iterator">Container Iterator</a>
    
      
      
      <a class="ui label" href="/tags/debug/" title="Debug">Debug</a>
    
      
      
      <a class="ui label" href="/tags/dp/" title="Dp">Dp</a>
    
      
      
      <a class="ui label" href="/tags/hugo/" title="Hugo">Hugo</a>
    
      
      
      <a class="ui label" href="/tags/rocksdb/" title="Rocksdb">Rocksdb</a>
    
      
      
      <a class="ui label" href="/tags/rpc-framework/" title="Rpc Framework">Rpc Framework</a>
    
      
      
      <a class="ui label" href="/tags/shared_ptr/" title="Shared Ptr">Shared Ptr</a>
    
      
      
      <a class="ui label" href="/tags/skiplist/" title="Skiplist">Skiplist</a>
    
      
      
      <a class="ui label" href="/tags/stl/" title="Stl">Stl</a>
    
      
      
      <a class="ui label" href="/tags/systemtap/" title="Systemtap">Systemtap</a>
    
      
      
      <a class="ui label" href="/tags/%E5%85%B6%E4%BB%96/" title="其他">其他</a>
    
      
      
      <a class="ui label" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分布式">分布式</a>
    
      
      
      <a class="ui label" href="/tags/%E6%95%B0%E4%BD%8D%E6%9E%9A%E4%B8%BE/" title="数位枚举">数位枚举</a>
    
      
      
      <a class="ui label" href="/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/" title="最长回文子串">最长回文子串</a>
    
      
      
      <a class="ui label" href="/tags/%E6%9D%82%E8%B0%88/" title="杂谈">杂谈</a>
    
    </article>
    
  </div>
</header>


<div class="ui relaxed grid dream-grid dream-back">
  
  
  

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment">
      <h3 class="ui header"></h3>
      <nav class="ui secondary menu dream-menu dream-socials">
  

  

  

  

  

  

  

  

  

  
</nav>

    </article>
  </div>

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
  </div>

  
  
</div>

          </div>
        </section>
      </div>
    </div>

    <script>
  window.defaultDark =  null 
  window.backgroundDark =  null 
  window.backgroundImageDark =  null 
  window.darkNav =  null 
  window.hasTwitterEmbed =  null 

  if (window.hasTwitterEmbed) {
    
    window.twttr = (function (d, s, id) {
      var js,
        fjs = d.getElementsByTagName(s)[0],
        t = window.twttr || {}
      if (d.getElementById(id)) return t
      js = d.createElement(s)
      js.id = id
      js.src = 'https://platform.twitter.com/widgets.js'
      fjs.parentNode.insertBefore(js, fjs)

      t._e = []
      t.ready = function (f) {
        t._e.push(f)
      }

      return t
    })(document, 'script', 'twitter-wjs')
  }
</script>
<script src="/js/jquery.min.js"></script>
<script src="/js/semantic.min.js"></script>
<script src="/js/jquery.overlayScrollbars.min.js"></script>
<script src="/js/header.js"></script>
<script src="/js/main.js"></script>
<script src="/js/theme.js"></script>

    
<script src="/js/html2canvas.min.js"></script>
<script src="/js/post.js"></script>





    

    

    
  </body>
</html>
